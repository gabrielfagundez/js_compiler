package com.language.parser;

import java.util.*;
import java_cup.runtime.*;
import com.language.model.*;
import com.language.exceptions.*;

terminal String NULL;

terminal String POINT;
terminal String SEMICOLON;
terminal String COMMA;
terminal String LEFT_ROUND_BRACKET;
terminal String RIGHT_ROUND_BRACKET;
terminal String DOUBLE_QUOTE;
terminal String SINGLE_QUOTE;
terminal String LEFT_SQUARE_BRACKET;
terminal String RIGHT_SQUARE_BRACKET;
terminal String VAR;
terminal String NEW;
terminal String RETURN;
terminal String FUNCTION;

terminal String LINE_BREAK;
terminal String TABULATION;
terminal String ESCAPE;

terminal String PLUS;
terminal String MINUS;
terminal String TIMES;
terminal String DIV;
terminal String EQUAL;
terminal String QUEST;
terminal String COLON;

terminal String INCREMENT;
terminal String DECREMENT;

terminal String TRUE;
terminal String FALSE;

terminal String AND;
terminal String OR;
terminal String NOT;

terminal String GREATER;
terminal String LESS;
terminal String GREATER_EQUAL;
terminal String LESS_EQUAL;
terminal String EQUAL_EQUAL;
terminal String NOT_EQUAL;

terminal String BLOCK_BEGIN;
terminal String BLOCK_END;
terminal String IF;
terminal String WHILE;
terminal String ELSE;
terminal String FOR;
terminal String BREAK;
terminal String CONTINUE;

terminal String LENGTH_FUNCT;
terminal String CONCAT_FUNCT;
terminal String TYPEOF_FUNCT;
terminal String TO_UPPER_CASE_FUNCT;
terminal String TO_LOWER_CASE_FUNCT;
terminal String CHAR_AT_FUNCT;
terminal String INDEX_OF_FUNCT;
terminal String LAST_INDEX_OF_FUNCT;
terminal String SUBSTRING_FUNCT;
terminal String SPLIT_FUNCT;

terminal String JOIN_FUNCT;
terminal String CONSOLE_LOG;
terminal String POP_FUNCT;
terminal String PUSH_FUNCT;
terminal String SHIFT_FUNCT;
terminal String REVERSE_FUNCT;

terminal String NAN;
terminal String IS_NAN;
terminal String PARSE_FUNCT;

terminal String STRING;

terminal String ID;
terminal String INTEGRAL;
terminal String DECIMAL;

/* Esta clase se considera inicial */
non terminal Object program;
non terminal Object top_statement;

/* Funciones especificas */
non terminal Object console_log;

non terminal Object variable_definition;
non terminal Object variable_declaration_list;
non terminal Object variable_declaration;
non terminal Object variable_initializer;

non terminal Expression logical_or_expression;
non terminal Expression logical_and_expression;
non terminal Expression equality_expression;
non terminal Expression relational_expression;
non terminal Expression additive_expression;
non terminal Expression multiplicative_expression;
non terminal Expression unary_expression;
non terminal Expression postfix_expression;

non terminal Expression expression;
non terminal Expression primary_expression;
non terminal Expression simple_expression;

non terminal Expression function_expression;
non terminal Expression object_literal; 
non terminal Expression assignment_expression; 
non terminal Expression conditional_expression; 
non terminal Expression parenthesized_expression; 
non terminal Expression left_side_expression;
non terminal Expression call_expression;
non terminal Expression optional_expression;
non terminal Expression short_new_expression;
non terminal Expression full_new_expression;
non terminal Object member_operator;
non terminal Object arguments;
non terminal Object full_new_subexpression;
non terminal Object short_new_subexpression;
non terminal Object compound_assignment;
non terminal Object argument_list;

non terminal Object field_list;
non terminal Object literal_field;
non terminal Object in_binding;

non terminal Object named_function;
non terminal Object for_initializer;

non terminal Object statement;
non terminal Object empty_statement;
non terminal Object known_function;
non terminal Object expression_statement;
non terminal Object optional_semicolon;
non terminal Object block;
non terminal Object labeled_statement;
non terminal Object if_statement;
non terminal Object switch_statemente;
non terminal Object do_statement;
non terminal Object while_statement;
non terminal Object for_statement;
non terminal Object with_statement;
non terminal Object continue_statement;
non terminal Object break_statement;
non terminal Object return_statement;
non terminal Object throw_statement;
non terminal Object try_statement;

non terminal Object array_literal;
non terminal Object element_list;
non terminal Object literal_element;

non terminal Object block_statements;
non terminal Object block_statements_prefix;

non terminal Object function_definition;
non terminal Object formal_parameters_and_body;
non terminal Object formal_parameters;
non terminal Object formal_parameter;
non terminal Object formal_parameters_prefix;
non terminal Object top_statements;
non terminal Object top_statements_prefix;

precedence left PLUS, MINUS;
precedence left TIMES, DIV;

/* Program */
 
program ::= 
    top_statements;
    
top_statements ::=
    |
    top_statements_prefix;
    
top_statements_prefix ::=
    top_statement |
    top_statements_prefix top_statement;
    
top_statement ::= 
    statement |
    function_definition;

/* Funciones especificas */
console_log ::= 
    CONSOLE_LOG LEFT_ROUND_BRACKET ID:var_name RIGHT_ROUND_BRACKET 
        {: 
            Variables variables = Variables.getInstance();
            Var var = variables.getVariableByName(var_name);
            ConsoleLog cl = new ConsoleLog((String)var.getValue());
            cl.execute();
            
        :};
    
known_function ::= 
    console_log;

optional_semicolon ::= SEMICOLON;

/* Expresiones */

primary_expression ::=
    simple_expression:se {: RESULT = se; :} |
    function_expression |
    object_literal;

simple_expression ::=
    NULL:n {: RESULT = new Expression(n,"NULL"); :} |
    TRUE:t {: RESULT = new Expression(t, "Boolean"); :} |
    FALSE:f {: RESULT = new Expression(f, "Boolean"); :} |
    INTEGRAL:i {: RESULT = new Expression(i, "Integer"); :} |
    DECIMAL:d {: RESULT = new Expression(d, "Float"); :} |
    STRING:s {: RESULT = new Expression(s, "String"); :} |
    ID:i {: RESULT = new Expression(i, "Var"); :} |
    parenthesized_expression:p {: RESULT = p; :} |
    array_literal;
    
parenthesized_expression ::=
    LEFT_ROUND_BRACKET conditional_expression:ce RIGHT_ROUND_BRACKET {: RESULT = ce; :} ;

function_expression ::=
    named_function;

object_literal ::=
    BLOCK_BEGIN BLOCK_END |
    BLOCK_BEGIN field_list BLOCK_END;
    
field_list ::=
    literal_field |
    field_list COMMA literal_field;
    
literal_field ::= 
    ID COLON assignment_expression;

array_literal ::=
    LEFT_SQUARE_BRACKET RIGHT_SQUARE_BRACKET |
    LEFT_SQUARE_BRACKET element_list RIGHT_SQUARE_BRACKET;

element_list ::=
    literal_element |
    element_list COMMA literal_element;

literal_element ::= assignment_expression;

left_side_expression ::= 
    call_expression:ce {: RESULT = ce ; :} |
    short_new_expression;

call_expression ::=
    primary_expression:pe {: RESULT = pe ; :} |
    full_new_expression |
    call_expression member_operator |
    call_expression arguments;
    
full_new_expression ::=
    NEW full_new_subexpression arguments;
    
short_new_expression ::=
    NEW short_new_subexpression;
    
full_new_subexpression ::=
    primary_expression |
    full_new_expression |
    full_new_subexpression member_operator;
    
short_new_subexpression ::=
    full_new_subexpression |
    short_new_expression;
    
member_operator ::=
    LEFT_SQUARE_BRACKET expression RIGHT_SQUARE_BRACKET |
    POINT ID;
    
arguments ::=
    LEFT_ROUND_BRACKET RIGHT_ROUND_BRACKET |
    LEFT_ROUND_BRACKET argument_list RIGHT_ROUND_BRACKET;
    
argument_list ::=
    assignment_expression |
    argument_list COMMA assignment_expression; 

postfix_expression ::=
    left_side_expression:lse {: RESULT = lse ; :} |
    left_side_expression INCREMENT |
    left_side_expression DECREMENT;

unary_expression ::=
    postfix_expression:pe {: RESULT = pe ; :} |
    TYPEOF_FUNCT unary_expression |
    INCREMENT unary_expression|
    DECREMENT unary_expression;

multiplicative_expression ::= 
    unary_expression:ue {: RESULT = ue ; :} |
    multiplicative_expression:l TIMES unary_expression:r {: RESULT = new Expression("*",l,r); :} |
    multiplicative_expression:l DIV unary_expression:r {: RESULT = new Expression("/",l,r); :} ;

additive_expression ::=
    multiplicative_expression:me {: RESULT = me ; :} |
    additive_expression:l PLUS multiplicative_expression:r {: RESULT = new Expression("+",l,r); :} |
    additive_expression:l MINUS multiplicative_expression:r {: RESULT = new Expression("-",l,r); :};

relational_expression ::=
    additive_expression:ae {: RESULT = ae ; :} |
    relational_expression:l GREATER additive_expression:r {: RESULT = new Expression(">",l,r) ; :} |
    relational_expression:l LESS additive_expression:r {: RESULT = new Expression("<",l,r) ; :} |
    relational_expression:l GREATER_EQUAL additive_expression:r {: RESULT = new Expression(">=",l,r) ; :} |
    relational_expression:l LESS_EQUAL additive_expression:r {: RESULT = new Expression("<=",l,r) ; :};

equality_expression ::=
    relational_expression:re {: RESULT = re ; :} |
    equality_expression:l EQUAL_EQUAL relational_expression:r {: RESULT = new Expression("==",l,r) ; :} |
    equality_expression:l NOT_EQUAL relational_expression:r {: RESULT = new Expression("!=",l,r) ; :};

logical_and_expression ::=
    equality_expression:ee {: RESULT = ee ; :} |
    logical_and_expression:l AND equality_expression:r {: RESULT = new Expression("&&",l,r) ; :};

logical_or_expression ::=
    logical_and_expression:lae {: RESULT = lae ; :} |
    logical_or_expression:l OR logical_and_expression:r {: RESULT = new Expression("||",l,r) ; :};

conditional_expression ::=
    logical_or_expression:lor {: RESULT = lor ; :} |
    logical_or_expression QUEST assignment_expression COLON assignment_expression;

assignment_expression ::=
    conditional_expression:ce {: RESULT = ce ; :} |
    left_side_expression EQUAL assignment_expression |
    left_side_expression compound_assignment assignment_expression;

expression ::=
    assignment_expression {:  :} |
    expression COMMA assignment_expression {:  :} ;

optional_expression ::=
    expression |
    ;

/* Statements */
statement ::=
    empty_statement {:  :} |
    known_function optional_semicolon {:  :} |
    expression_statement optional_semicolon {:  :} |
    variable_definition optional_semicolon {:  :} |
    block {:  :} |
    labeled_statement {:  :} |
    if_statement {:  :} |
    switch_statemente {:  :} |
    do_statement optional_semicolon {:  :} |
    while_statement {:  :} |
    for_statement {:  :} |
    with_statement {:  :} |
    continue_statement optional_semicolon {:  :} |
    break_statement optional_semicolon {:  :} |
    return_statement optional_semicolon {:  :} |
    throw_statement optional_semicolon {:  :} |
    try_statement {:  :} ;

empty_statement ::= SEMICOLON;

expression_statement ::= expression {: System.out.println("Detecte un expression"); :} ;


/* Definiciones de Variables */

variable_definition ::= 
    VAR variable_declaration_list;

variable_declaration_list ::=
    variable_declaration |
    variable_declaration_list COMMA variable_declaration;

variable_declaration ::= 
    ID:id variable_initializer;
    
variable_initializer ::=
    |
    EQUAL assignment_expression:a
    	{:
         	Object value = a.evaluate();
         	String type = a.getType();
         	System.out.println(value);
         	System.out.println(type);
    	:};    

/* Definiciones de Bloques */

block ::=
    BLOCK_BEGIN block_statements BLOCK_END;
    
block_statements ::=
    block_statements_prefix;
    
block_statements_prefix ::=
    statement |
    block_statements_prefix statement;
    
if_statement ::= 
    IF parenthesized_expression statement;
    
while_statement ::= 
    WHILE parenthesized_expression statement;
    
for_statement ::=
    FOR LEFT_ROUND_BRACKET for_initializer SEMICOLON optional_expression SEMICOLON optional_expression RIGHT_ROUND_BRACKET statement;
    
for_initializer ::=
    |
    expression |
    VAR variable_declaration_list;
    
in_binding ::=
    left_side_expression |
    VAR variable_declaration_list;
    
return_statement ::=
    RETURN optional_expression;
    
/* Funciones */

function_definition ::=
    FUNCTION ID formal_parameters_and_body {:  :};

formal_parameters_and_body ::=
    LEFT_ROUND_BRACKET formal_parameters RIGHT_ROUND_BRACKET BLOCK_BEGIN top_statements BLOCK_END {:  :};

formal_parameters ::=
    |
    formal_parameters_prefix {:  :};

formal_parameters_prefix ::=
    ID {:  :} |
    formal_parameters_prefix COMMA ID {:  :};
