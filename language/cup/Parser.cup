package com.language.parser;

import java.util.*;
import java_cup.runtime.*;
import com.language.model.*;
import com.language.controller.*;
import com.language.exceptions.*;

terminal String NULL;

terminal String POINT;
terminal String SEMICOLON;
terminal String COMMA;
terminal String LEFT_ROUND_BRACKET;
terminal String RIGHT_ROUND_BRACKET;
terminal String DOUBLE_QUOTE;
terminal String SINGLE_QUOTE;
terminal String LEFT_SQUARE_BRACKET;
terminal String RIGHT_SQUARE_BRACKET;
terminal String VAR;
terminal String NEW;
terminal String RETURN;
terminal String FUNCTION;
terminal String ALERT;

terminal String LINE_BREAK;
terminal String TABULATION;
terminal String ESCAPE;

terminal String PLUS;
terminal String MINUS;
terminal String TIMES;
terminal String DIV;
terminal String EQUAL;
terminal String QUEST;
terminal String COLON;

terminal String INCREMENT;
terminal String DECREMENT;

terminal String TRUE;
terminal String FALSE;

terminal String AND;
terminal String OR;
terminal String NOT;

terminal String GREATER;
terminal String LESS;
terminal String GREATER_EQUAL;
terminal String LESS_EQUAL;
terminal String EQUAL_EQUAL;
terminal String NOT_EQUAL;

terminal String BLOCK_BEGIN;
terminal String BLOCK_END;
terminal String IF;
terminal String WHILE;
terminal String ELSE;
terminal String FOR;
terminal String BREAK;
terminal String CONTINUE;

terminal String LENGTH_FUNCT;
terminal String CONCAT_FUNCT;
terminal String TYPEOF_FUNCT;
terminal String TO_UPPER_CASE_FUNCT;
terminal String TO_LOWER_CASE_FUNCT;
terminal String CHAR_AT_FUNCT;
terminal String INDEX_OF_FUNCT;
terminal String LAST_INDEX_OF_FUNCT;
terminal String SUBSTRING_FUNCT;
terminal String SPLIT_FUNCT;

terminal String JOIN_FUNCT;
terminal String CONSOLE_LOG;
terminal String POP_FUNCT;
terminal String PUSH_FUNCT;
terminal String SHIFT_FUNCT;
terminal String REVERSE_FUNCT;

terminal String NAN;
terminal String IS_NAN;
terminal String PARSE_FUNCT;

terminal String STRING;

terminal String ID;
terminal String INTEGRAL;
terminal String DECIMAL;

/* Esta clase se considera inicial */
non terminal Ast program;
non terminal Ast top_statement;

/* Funciones especificas */
non terminal Ast console_log;
non terminal Ast alert;

non terminal Object variable_definition;
non terminal Ast variable_declaration_list;
non terminal Ast variable_declaration;
non terminal Ast variable_initializer;

non terminal Ast logical_or_expression;
non terminal Ast logical_and_expression;
non terminal Ast equality_expression;
non terminal Ast relational_expression;
non terminal Ast additive_expression;
non terminal Ast multiplicative_expression;
non terminal Ast unary_expression;
non terminal Ast postfix_expression;

non terminal Ast expression;
non terminal Ast primary_expression;
non terminal Ast simple_expression;

non terminal Ast function_expression;
non terminal Ast object_literal; 
non terminal Ast assignment_expression; 
non terminal Ast conditional_expression; 
non terminal Ast parenthesized_expression; 
non terminal Ast left_side_expression;
non terminal Ast call_expression;
non terminal Ast optional_expression;
non terminal Ast short_new_expression;
non terminal Ast full_new_expression;
non terminal Ast member_operator;
non terminal Object arguments;
non terminal Object full_new_subexpression;
non terminal Object short_new_subexpression;
non terminal Object compound_assignment;
non terminal Object argument_list;

non terminal Object field_list;
non terminal Object literal_field;
non terminal Object in_binding;

non terminal Object named_function;
non terminal Object for_initializer;

non terminal Ast statement;
non terminal Ast empty_statement;
non terminal Ast known_function;
non terminal Ast expression_statement;
non terminal Ast optional_semicolon;
non terminal Ast block;
non terminal Ast labeled_statement;
non terminal Ast if_statement;
non terminal Ast switch_statemente;
non terminal Ast do_statement;
non terminal Ast while_statement;
non terminal Ast for_statement;
non terminal Ast with_statement;
non terminal Ast continue_statement;
non terminal Ast break_statement;
non terminal Ast return_statement;
non terminal Ast throw_statement;
non terminal Ast try_statement;

non terminal Object array_literal;
non terminal Ast element_list;
non terminal Ast literal_element;

non terminal Ast block_statements;
non terminal Ast block_statements_prefix;

non terminal Object function_definition;
non terminal Object formal_parameters_and_body;
non terminal Object formal_parameters;
non terminal Object formal_parameter;
non terminal Object formal_parameters_prefix;
non terminal Object top_statements;
non terminal Object top_statements_prefix;

precedence left PLUS, MINUS;
precedence left TIMES, DIV;

/* Program */

program ::= 
    top_statements 
        {:  
            AstController asts = AstController.getInstance();
            asts.execute();
        :};

top_statements ::=
    |
    top_statements_prefix;

top_statements_prefix ::=
    top_statement |
    top_statements_prefix top_statement;

top_statement ::= 
    statement:stmt 
        {:  
            AstController asts = AstController.getInstance();
            asts.addStatement(stmt);
        :} |
    function_definition;

/* Funciones especificas */
console_log ::= 
    CONSOLE_LOG LEFT_ROUND_BRACKET expression:ae RIGHT_ROUND_BRACKET
        {: RESULT = Ast.createConsoleLogNode(ae); :};
        
alert ::= 
    ALERT LEFT_ROUND_BRACKET expression:ae RIGHT_ROUND_BRACKET
        {: RESULT = Ast.createAlertNode(ae); :};
    
known_function ::= 
    console_log:cl {: RESULT = cl; :} |
    alert:a {: RESULT = a; :};

optional_semicolon ::= SEMICOLON;

/* Expresiones */

primary_expression ::=
    simple_expression:se {: RESULT = se; :} |
    function_expression |
    object_literal;

simple_expression ::=
    NULL:n {: RESULT = Ast.createNullNode(); :} |
    TRUE:t {: RESULT = Ast.createBooleanNode(t); :} |
    FALSE:f {: RESULT = Ast.createBooleanNode(f); :} |
    INTEGRAL:i {: RESULT = Ast.createIntegerNode(i); :} |
    DECIMAL:d {: RESULT = Ast.createFloatNode(d); :} |
    STRING:s {: RESULT = Ast.createStringNode(s); :} |
    ID:i {: RESULT = Ast.createVarNode(i); :} |
    parenthesized_expression:p {: RESULT = p; :} |
    array_literal:a {: RESULT = Ast.createArrayNode(a); :} ;

parenthesized_expression ::=
    LEFT_ROUND_BRACKET conditional_expression:ce RIGHT_ROUND_BRACKET {: RESULT = ce; :} ;

function_expression ::=
    named_function;

object_literal ::=
    BLOCK_BEGIN BLOCK_END |
    BLOCK_BEGIN field_list BLOCK_END;

field_list ::=
    literal_field |
    field_list COMMA literal_field;

literal_field ::= 
    ID COLON assignment_expression;

array_literal ::=
    LEFT_SQUARE_BRACKET RIGHT_SQUARE_BRACKET {: RESULT = new Ast(Ast.ARRAY, null, null); :} |
    LEFT_SQUARE_BRACKET element_list:el RIGHT_SQUARE_BRACKET {: RESULT = el; :} ;

element_list ::=
    literal_element:le {: RESULT = le; :} |
    element_list:el COMMA literal_element:le {: RESULT = new Ast(Ast.ARRAY, el, le); :} ;

literal_element ::= assignment_expression:ae {: RESULT = ae; :};

left_side_expression ::= 
    call_expression:ce {: RESULT = ce ; :} |
    short_new_expression;

call_expression ::=
    primary_expression:pe {: RESULT = pe ; :} |
    full_new_expression |
    call_expression:ce member_operator:mo {: ce.evaluateArray(mo); :} |
    call_expression arguments;
    
full_new_expression ::=
    NEW full_new_subexpression arguments;
    
short_new_expression ::=
    NEW short_new_subexpression;
    
full_new_subexpression ::=
    primary_expression |
    full_new_expression |
    full_new_subexpression member_operator;
    
short_new_subexpression ::=
    full_new_subexpression |
    short_new_expression;
    
member_operator ::=
    LEFT_SQUARE_BRACKET expression:e RIGHT_SQUARE_BRACKET {: RESULT = e; :} |
    POINT ID;

arguments ::=
    LEFT_ROUND_BRACKET RIGHT_ROUND_BRACKET |
    LEFT_ROUND_BRACKET argument_list RIGHT_ROUND_BRACKET;

argument_list ::=
    assignment_expression {:  :} |
    argument_list COMMA assignment_expression; 

postfix_expression ::=
    left_side_expression:lse {: RESULT = lse ; :} |
    left_side_expression INCREMENT |
    left_side_expression DECREMENT;

unary_expression ::=
    postfix_expression:pe {: RESULT = pe ; :} |
    TYPEOF_FUNCT unary_expression |
    INCREMENT unary_expression|
    DECREMENT unary_expression |
    NOT unary_expression:not {: RESULT = new Ast(Ast.NOT,not,null) ; :};

multiplicative_expression ::= 
    unary_expression:ue {: RESULT = ue ; :} |
    multiplicative_expression:l TIMES unary_expression:r {: RESULT = new Ast(Ast.TIMES, l, r); :} |
    multiplicative_expression:l DIV unary_expression:r {: RESULT = new Ast(Ast.DIV, l, r); :} ;

additive_expression ::=
    multiplicative_expression:me {: RESULT = me ; :} |
    additive_expression:l PLUS multiplicative_expression:r {: RESULT = new Ast(Ast.PLUS, l, r); :} |
    additive_expression:l MINUS multiplicative_expression:r {: RESULT = new Ast(Ast.MINUS, l, r); :};

relational_expression ::=
    additive_expression:ae {: RESULT = ae ; :} |
    relational_expression:l GREATER additive_expression:r {: RESULT = new Ast(Ast.GREATER, l, r) ; :} |
    relational_expression:l LESS additive_expression:r {: RESULT = new Ast(Ast.LESS, l, r) ; :} |
    relational_expression:l GREATER_EQUAL additive_expression:r {: RESULT = new Ast(Ast.GREATER_EQ, l, r) ; :} |
    relational_expression:l LESS_EQUAL additive_expression:r {: RESULT = new Ast(Ast.LESS_EQ, l, r) ; :};

equality_expression ::=
    relational_expression:re {: RESULT = re ; :} |
    equality_expression:l EQUAL_EQUAL relational_expression:r {: RESULT = new Ast(Ast.EQ_EQ, l, r) ; :} |
    equality_expression:l NOT_EQUAL relational_expression:r {: RESULT = new Ast(Ast.NOT_EQ, l, r) ; :};

logical_and_expression ::=
    equality_expression:ee {: RESULT = ee ; :} |
    logical_and_expression:l AND equality_expression:r {: RESULT = new Ast(Ast.AND, l, r) ; :};

logical_or_expression ::=
    logical_and_expression:lae {: RESULT = lae ; :} |
    logical_or_expression:l OR logical_and_expression:r {: RESULT = new Ast(Ast.OR, l, r) ; :};

conditional_expression ::=
    logical_or_expression:lor {: RESULT = lor ; :} |
    logical_or_expression QUEST assignment_expression COLON assignment_expression;

assignment_expression ::=
    conditional_expression:ce {: RESULT = ce; :} |
    left_side_expression EQUAL assignment_expression |
    left_side_expression compound_assignment assignment_expression;

expression ::=
    assignment_expression:a {: RESULT = a; :} |
    expression COMMA assignment_expression:a {: RESULT = a; :} ;

optional_expression ::=
    expression:e {: RESULT = e; :} |
    ;

/* Statements */
statement ::=
    empty_statement:stmts {: RESULT = stmts; :} |
    known_function:stmts optional_semicolon {:RESULT = stmts; :} |
    expression_statement:stmts optional_semicolon {: RESULT = stmts; :} |
    variable_definition optional_semicolon:stmts {: RESULT = stmts; :} |
    block:stmts {: RESULT = stmts; :} |
    labeled_statement:stmts {: RESULT = stmts; :} |
    if_statement:stmts {: RESULT = stmts; :} |
    switch_statemente:stmts {: RESULT = stmts; :} |
    do_statement:stmts optional_semicolon {: RESULT = stmts; :} |
    while_statement:stmts {: RESULT = stmts; :} |
    for_statement:stmts {: RESULT = stmts; :} |
    with_statement:stmts {: RESULT = stmts; :} |
    continue_statement:stmts optional_semicolon {: RESULT = stmts; :} |
    break_statement:stmts optional_semicolon {: RESULT = stmts; :} |
    return_statement:stmts optional_semicolon {: RESULT = stmts; :} |
    throw_statement:stmts optional_semicolon {: RESULT = stmts; :} |
    try_statement:stmts {: RESULT = stmts; :} ;

empty_statement ::= SEMICOLON;

expression_statement ::= expression:e {: RESULT = e; :} ;


/* Definiciones de Variables */

variable_definition ::= 
    VAR variable_declaration_list;

variable_declaration_list ::=
    variable_declaration |
    variable_declaration_list COMMA variable_declaration;

variable_declaration ::= 
    ID:id variable_initializer:vi {: VariablesController.getInstance().addVariable(id, vi); :};
    
variable_initializer ::=
    |
    EQUAL assignment_expression:a {: RESULT = a; :};

/* Definiciones de Bloques */

block ::=
    BLOCK_BEGIN block_statements:bs BLOCK_END {: RESULT = bs; :};
    
block_statements ::=
    block_statements_prefix:bs {: RESULT = bs; :};
    
block_statements_prefix ::=
    statement:bs {: RESULT = bs; :} |
    block_statements_prefix statement;
    
if_statement ::= 
    IF parenthesized_expression:e statement:s {: RESULT = new Ast(Ast.IF, s, null, e); :};
    
while_statement ::= 
    WHILE parenthesized_expression statement;
    
for_statement ::=
    FOR LEFT_ROUND_BRACKET for_initializer SEMICOLON optional_expression SEMICOLON optional_expression RIGHT_ROUND_BRACKET statement;
    
for_initializer ::=
    |
    expression |
    VAR variable_declaration_list;
    
in_binding ::=
    left_side_expression |
    VAR variable_declaration_list;
    
return_statement ::=
    RETURN optional_expression;
    
/* Funciones */

function_definition ::=
    FUNCTION ID:funct_name LEFT_ROUND_BRACKET formal_parameters RIGHT_ROUND_BRACKET BLOCK_BEGIN statement:stmts BLOCK_END 
        {: 
            FunctionsController f = FunctionsController.getInstance(); 
            f.addFunction(funct_name, stmts);
        :};

formal_parameters ::=
    |
    formal_parameters_prefix {:  :};

formal_parameters_prefix ::=
    ID {:  :} |
    formal_parameters_prefix COMMA ID {:  :};
